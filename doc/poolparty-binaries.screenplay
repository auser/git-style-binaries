#!/usr/bin/env castanaut
# Castanaut screencast file. sudo gem install castanaut

# see if there is a terminal module
# download the 'ttyrecord' binary
# get castanaut src
# get applescript docs
plugin "terminal"
plugin "keystack"

perform "Introduction" do
  launch "Terminal", at(10, 10, 800, 600)

  say <<-eos
  Hey, welcome to the git-style-binaries screencast. 
  First, lets talk a little about what a git-style-binary even is. 
  eos
end

cli "cd #{ENV['POOLPARTY_SRC']}" 

# perform "Describing Git Binaries" do
#   pause 1
#   while_saying "as you can see here, git has over one hundred binaries that all perform various functions." do
#     type "git-"
#     pause 1
#     keystroke_literal('tab')
#     keystroke_literal('tab')
#     type "y"
#     pause 2
#     type " "
#     keystroke_using('u', :control)
#   end

#   while_saying "for instance, we have. git-add for adding files. git-status for
#   getting the status of our repo and so on" do
#     cli "git-add"
#     pause 2
#     cli "git-status"
#   end

#   while_saying "one of the nice things about the git-style-binaries is that you
#   can choose to call the command with or without the dash.. so for instance, i
#   can call either 'git-add' or 'git add'." do
#   end

#   perform "Describe Help" do
#     while_saying "the help in git is also very handy. for instance, if you call
#     git -h it will give you a listing of many of the available subcommands" do
#     end

#     while_saying "you can get the same effect by typing 'git help'" do
#     end

#     while_saying "you can also ask for help about any of the subcommands. if we
#     want to get help on 'git-add', we simply type 'git help add'" do
#     end
#   end

#   perform "Describe Validation" do
#     while_saying "git also performs option validation, as you would expect. for
#     instance, if we provide an invalid option such as 'asdf' we get an error" do
#       cli "git add --asdf"
#     end
#   end

# end

# while_saying "the goal of the ruby gem git-style-binaries is to bring this
# functionality to your own custom binaries in an easy-to-use way" do
# end

# pause 2

# perform "Introducing PoolParty" do
#   while_saying "we're going to be using PoolParty's binaries as an example on how to build git-style-binaries using this gem" do
#   end


#   while_saying "just in case you're not familiar with poolparty, its a cloud
#   management system by Ari Lerner. It allows you to manage your cloud using ruby
#   code and plugins rather than, say, folders of bash scripts." do
#   open safari poolpartyrb.com
#   end

#   while_saying "in poolparty the main binary is 'cloud'. we can do cloud help to see all of the available subcommands." do
#   end

#   while_saying "as you can see here we have 'cloud-start', for starting our
#   cloud, 'cloud configure' to reconfigure our cloud after we change something,
#   even cloud-ssh, to ssh directly into a node of our cloud."

#   pause 2

#   while_saying "what i'd like to do is, rather than just opening up the existing
#   binaries, Im going to build poolparty-like binaries from the ground up. this
#   way you can see how to do this on your own."
# end

cli "cd ~" 
cli "mkdir -p poolparty-gsb-test/bin"
cli "cd poolparty-gsb-test"
 
# perform "creating primary" do
#     while_saying "first we need to create our *primary* binary." do
#       cli "vim bin/cloud"
#       pause 2
#       type_pre <<-eof 
# i#!/usr/bin/env ruby
# require 'git-style-binary/command'
# eof
#       cli ":w"
#       cli ":e"
#     end

#     while_saying "and thats it! thats all we need if we want the default functionality"  do
#       cli ":x"
#     end
# end

pause 1

# opt :cloud_name, "Name of the working cloud", :type => String, :default => nil

perform "creating subcommands" do
  while_saying "now lets create cloud-start.
  we start by requiring git-style-binary/command, just like last time.
  now we open up a #command block.
  specify a version.
  specify a banner and a short description.
  and we put what we want to do in the 'run' block." do

  cli "vim bin/cloud-start"
  pause 1
  vim_insert <<-eof
#!/usr/bin/env ruby
eof
  cli ":w"
  cli ":e"
  cli ":set paste" # no auto indending
  type "j"

  vim_insert <<-eof
require 'git-style-binary/command'

GitStyleBinary.command do
  version "PoolParty cloud-start 0.0.1"  
  banner <<-\EOS
Usage: \#{\$0} \#{all_options_string}

EOS
eof

  vim_insert <<-eof
  short_desc "List the clouds"

  run do |command|
    puts "Options: \#{command.opts.inspect}"
  end
end
eof
  end

  while_saying "the run block yields a command object. commands has an 'opts' attribute accessor, or you can just use brackets on 'command'" do
    type ":0/putsDiputs \"verbose is: \#{command[:verbose]}\""
    cli ":w"
  end

  while_saying "you can add more options by calling 'opt' in the command block" do
    # add more options
  end
  while_saying "git-style-binaries uses the gem trollop for the option parsing.
  trollop allows you to easily add validations and type conversions to options.
  see their website for information on the syntax" do
  end

  while_saying "now lets run cloud-start -h" do
    # run it
  end
  while_saying "notice a few things here. we've got automatic coloring, a list of all of our flags, and a list of all of our options. trollop has even automatically created the short flags for us"  do
    # move the mouse over the right areas
  end

  while_saying "i'd like to show you a few more features of gsb. first lets create one more simple binary - cloud ssh" do

  cli "vim bin/cloud-ssh"
  pause 1
  vim_insert <<-eof
#!/usr/bin/env ruby
eof
  cli ":w"
  cli ":e"
  cli ":set paste" # no auto indending
  type "j"

  vim_insert <<-eof
require 'git-style-binary/command'

GitStyleBinary.command do
  version "PoolParty cloud-ssh 0.0.1"  
  banner <<-\EOS
Usage: \#{\$0} \#{all_options_string}

EOS
eof

  vim_insert <<-eof
  short_desc "ssh into your cloud"
  opt :name,    "name of the cloud", :type => String

  run do |command|
    puts "you're ssh'ing into \#{command[:name]}!"
  end
end
eof
  end

  while_saying "now we have two binaries, cloud-start and cloud-ssh" do
    cli "tree ."
  end

  while_saying "one of the cool things about gsb is that it will automatically pick up these files when you run the help commands" do
    cli "cloud -h"
  end

  while_saying "see, here we have both cloud-start and cloud-ssh, along with their short descriptions, which are automatically loaded from their respective files" do
    # move mouse
  end

end

perform "subcommand inherits primary" do

  # adding options to primary gives options to the secondary
  # adding before_run blocks to the primary
  # primary -h shows the list of subcommands
  # short theme

  while_saying "notice that if we do cloud help start. we see that it already has a number of options. these options come from the default binary options. " do
  end

  while_saying "gsb's get their options from three places 1) the default in code 2) the primary and 3) the subcommand itself" do
  end

  while_saying "if we add options to our primary these will be automatically inherited by the subcommands."

  while_saying "here we add a "

end



def cleanup
  FileUtils.rm_rf(File.expand_path("~/poolparty-gsb-test/bin"))
end

cleanup

# vim: ft=ruby
